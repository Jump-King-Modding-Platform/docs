[{"title":"Installation","type":0,"sectionRef":"#","url":"getting-started/installation","content":"","keywords":""},{"title":"Choosing an IDE​","type":1,"pageTitle":"Installation","url":"getting-started/installation#choosing-an-ide","content":""},{"title":"Option 1: Visual Studio​","type":1,"pageTitle":"Installation","url":"getting-started/installation#option-1-visual-studio","content":"tip Recommended for beginners. Download here When installing make sure to include support for desktop development for C# and .NET Framework 4.6.2. "},{"title":"Option 2: Rider (requires purchase)​","type":1,"pageTitle":"Installation","url":"getting-started/installation#option-2-rider-requires-purchase","content":"Download here It might also require the installation of .NET SDK when targeting older .NET Framework versions such as 4.6.2. If you're having problems with compiling it's worth a try. "},{"title":"Option 3: Other (using .NET SDK)​","type":1,"pageTitle":"Installation","url":"getting-started/installation#option-3-other-using-net-sdk","content":"Download here This option generally supports any editor since you'll be doing the compiling from a terminal instead. This guide won't be going into the details of that so only use this option if you know what you're doing. Note that you'll need both the x86 and x64 version if your operating system is 64-bit. In addition you'll also need .NET Framework 4.6.2 Developer Pack. "},{"title":"Project Setup","type":0,"sectionRef":"#","url":"getting-started/project-setup/","content":"Project Setup There's three ways to go about creating a plugin. Use a template.Create the project yourself and set everything up manually to fit your needs.Create a content-only plugin that doesn't add to or modify the game's code. This does not require an IDE or any other software aside from a text editor. We'll go over each of these scenarios in the next 3 steps. Choose the one you prefer.","keywords":""},{"title":"Content","type":0,"sectionRef":"#","url":"content","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Content","url":"content#introduction","content":"All plugins have a Content directory that will be searched when looking for content. When the game and plugins attempt to load content via the ContentManager class, it will search in each plugin's Content folder, prioritizing the last loaded plugin. If none of the plugins have the requested file, it will search the game's Content folder. "},{"title":"Adding content​","type":1,"pageTitle":"Content","url":"content#adding-content","content":"If you want to add new content with your plugin you should create a subdirectory in your plugin's Content folder. It can technically be anything, but it's recommended to use the plugin id. "},{"title":"Example​","type":1,"pageTitle":"Content","url":"content#example","content":"Folder structure MyContentPlugin | plugin.json └───Content | └───MyContentPlugin | └───my_texture.xnb  MyContentPlugin.cs private void LoadContent(ContentManager content) { Texture2D myTexture = content.Load&lt;Texture2D&gt;(&quot;MyContentPlugin/my_texture&quot;); }  "},{"title":"Replacing content​","type":1,"pageTitle":"Content","url":"content#replacing-content","content":"If you want to replace content from the game or another plugin, you need to match the folder structure of the content you're replacing. "},{"title":"Examples​","type":1,"pageTitle":"Content","url":"content#examples","content":"Replace the title logo texture​ MyContentPlugin | plugin.json └───Content | └───title_logo.xnb  Replace another mod's content​ MyContentPlugin | plugin.json └───Content | └───SomePlugin | └───some_texture.xnb  tip It's recommended to depend on the plugin you're replacing content from, so that it's guaranteed your plugin's content will take priority. "},{"title":"Create a content-only plugin","type":0,"sectionRef":"#","url":"getting-started/project-setup/content-plugin","content":"","keywords":""},{"title":"Create plugin directory​","type":1,"pageTitle":"Create a content-only plugin","url":"getting-started/project-setup/content-plugin#create-plugin-directory","content":"Create a folder with a unique name of your plugin. The name should not contain any spaces or special characters. "},{"title":"Create the plugin metadata file​","type":1,"pageTitle":"Create a content-only plugin","url":"getting-started/project-setup/content-plugin#create-the-plugin-metadata-file","content":"Core uses a meta data file called plugin.json to read information about the plugin. As is evident from the name, it should be formatted as JSON. An example of the metadata file is shown below: { &quot;name&quot;: &quot;My Content Plugin&quot;, &quot;description&quot;: &quot;This is my content plugin, it does stuff.&quot;, &quot;version&quot;: &quot;1.0.0&quot;, // Semantic versioning &quot;authors&quot;: [ &quot;My Name&quot; ], &quot;dependencies&quot;: { &quot;SomePlugin&quot;: &quot;^1.0.0&quot; // A version range, same syntax as npm if you're familiar with it. }, &quot;onlyContent&quot;: true // This is a flag that tells Core that this plugin only contains content. }  This file should be included with the plugin. To read more about the metadata file, visit the Plugin Metadata page. "},{"title":"Create content files​","type":1,"pageTitle":"Create a content-only plugin","url":"getting-started/project-setup/content-plugin#create-content-files","content":"Create a folder called Content inside the plugin directory. This folder will basically act as the &quot;root&quot; of the Jump King\\Content directory. If you want to overwrite vanilla or another plugin's content, you can match the directory structure of those files. For example, if you want to replace the vanilla title logo screen, your folder structure would be: MyContentPlugin | plugin.json └───Content | └───title_logo.xnb  There are various tools available to convert your files into xnb files. I recommend using the MGCB Editor (MonoGame Content Builder), but any tool that can convert your files into xnb files should work. It is included with the MonoGame SDK installer which you can download here. note After installing you can find the tool by searching for MonoGame Pipeline in the start menu. "},{"title":"Copy to game directory​","type":1,"pageTitle":"Create a content-only plugin","url":"getting-started/project-setup/content-plugin#copy-to-game-directory","content":"When you want to test your plugin, you can copy it to the following game directory: Jump King\\JKMP\\Plugins\\MyContentPlugin. You can also just develop the plugin from the game directory if you want. "},{"title":"Create a plugin manually","type":0,"sectionRef":"#","url":"getting-started/project-setup/manual-setup","content":"","keywords":""},{"title":"Create the project​","type":1,"pageTitle":"Create a plugin manually","url":"getting-started/project-setup/manual-setup#create-the-project","content":"Start off by creating a new C# class library project. It needs to target .NET Framework 4.6.2 and target x86. important The project's assembly name needs to match JKMP.Plugin.&lt;NameOfPlugin&gt;. The plugin will not work if done incorrectly due to how plugins are searched for and loaded by Core. Add the following nuget package references: JKMP.CoreJKMP.Core.Analyzers (Optional, but recommended since it provides compile error and warning messages for runtime errors) "},{"title":"Create the plugin class​","type":1,"pageTitle":"Create a plugin manually","url":"getting-started/project-setup/manual-setup#create-the-plugin-class","content":"Create a new class in the JKMP.Plugin.&lt;NameOfPlugin&gt; namespace called &lt;NameOfPlugin&gt;Plugin. So for example if &lt;NameOfPlugin&gt; is FallKing, the class name including the namespace should be called JKMP.Plugin.FallKing.FallKingPlugin. Derive from the JKMP.Core.Plugins.Plugin class. Make sure the class follows these rules: The class is not abstract.The class is public.The class has a public constructor with no parameters, or no constructors at all. If any of these rules are not met, the plugin will fail to load. If you added the Analyzers package mentioned above, you'll get compile errors. Here's an example: namespace JKMP.Plugin.FallKing; public class FallKingPlugin : JKMP.Core.Plugins.Plugin { // Use intellisense to see what methods you can override and other properties you can use. }  "},{"title":"Create the metadata file​","type":1,"pageTitle":"Create a plugin manually","url":"getting-started/project-setup/manual-setup#create-the-metadata-file","content":"Core uses a meta data file called plugin.json to read information about the plugin. As is evident from the name, it should be formatted as JSON. An example of the metadata file is shown below: { &quot;name&quot;: &quot;My Plugin&quot;, &quot;description&quot;: &quot;This is my plugin, it does stuff.&quot;, &quot;version&quot;: &quot;1.0.0&quot;, // Semantic versioning &quot;authors&quot;: [ &quot;My Name&quot; ], &quot;dependencies&quot;: { &quot;SomePlugin&quot;: &quot;^1.0.0&quot; // A version range, same syntax as npm if you're familiar with it. } }  This file should be included with the plugin. To read more about the metadata file, visit the Plugin Metadata page. "},{"title":"Copy the plugin to the game's directory​","type":1,"pageTitle":"Create a plugin manually","url":"getting-started/project-setup/manual-setup#copy-the-plugin-to-the-games-directory","content":"After building the plugin, you can copy it to the following game directory: Jump King\\JKMP\\Plugins\\&lt;NameOfPlugin&gt; The following files should be included: JKMP.Plugin.&lt;NameOfPlugin&gt;.dllplugin.json And any other dependencies or content that the plugin needs. Note that dependencies can be placed in a subdirectory called Dependencies. Content needs to be placed in a subdirectory called Content. Here's an example of a plugin's directory structure: MyPlugin | JKMP.Plugin.MyPlugin.dll | plugin.json └───Dependencies | └───MyDependency.dll └───Content | └───MyPlugin | └───MyContent.png  To read more about content, see the Content section. Any potential dependencies to other plugins should not be included with the plugin. These will be resolved by Core. "},{"title":"Create a plugin using a template","type":0,"sectionRef":"#","url":"getting-started/project-setup/using-a-template","content":"","keywords":""},{"title":"Install project templates​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#install-project-templates","content":"To make developing plugins easier there is a template package available that offers JKMP related project templates. To proceed, you'll need to install the .NET SDK. Next, open a command prompt/terminal and type the following command. It will install the templates globally on your computer. The same command can be used to update to the latest version. dotnet new --install JKMP.ProjectTemplates  "},{"title":"Create the project​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#create-the-project","content":"tip If you're using Visual Studio you can use the New Project wizard instead. You should see JKMP Plugin in the list of templates. Open a command prompt/terminal in the folder that you want to create the project, and then type the following command: dotnet new jkmp-plugin -n &lt;NameOfPlugin&gt;  info Replace &lt;NameOfPlugin&gt; with the name of your plugin (without the angled brackets). Note that the name will automatically be prefixed with JKMP.Plugin.&lt;NameOfPlugin&gt;. This is due to how Core looks for plugins to load. Now you should have a solution in the current folder with a project called JKMP.Plugin.&lt;NameOfPlugin&gt;. "},{"title":"Setting up the project​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#setting-up-the-project","content":""},{"title":"Configure the path to the Jump King game directory​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#configure-the-path-to-the-jump-king-game-directory","content":"If you want to copy the plugin to the game's directory when you build it, you'll need to set the path to the game directory. You should see a file called DevVars.targets.example in the root of your project. Copy and paste this to a new file called DevVars.targets. Open the file and replace the example &lt;GameDirectory /&gt; items with the path to the game directory. Multiple directories can be used by adding multiple entries. So for example, if your game is located in the following directory: C:\\Steam\\steamapps\\common\\Jump King\\ &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt; &lt;ItemGroup&gt; &lt;GameDirectory Include=&quot;C:\\Steam\\steamapps\\common\\Jump King&quot; /&gt; &lt;/ItemGroup&gt; &lt;/Project&gt;  UNC paths are supported as well, such as: \\\\server\\games\\Jump King "},{"title":"Configure plugin meta data​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#configure-plugin-meta-data","content":"Open the JKMP.Plugin.&lt;NameOfPlugin&gt;.csproj file in your preferred text editor. Near the top you should see &lt;!-- Package/plugin properties --&gt; The properties under this section are used to configure the plugin. Set them as you see fit. Here is a list of the properties you can set: Property\tDescriptionPackageId\tThe package ID of the plugin. Only used if you're building and publishing a nuget package. PluginId\tThe unique identifier of the plugin. It's generally not changed since the template sets it automatically. It should match your &lt;NameOfPlugin&gt;. Version\tThe version of the plugin. This is used to determine the version of the plugin when you publish it. The version should follow the semantic versioning scheme. Title\tThe name of the plugin. This is the UI version that the users who install your plugin will see. PackageDescription\tThe description of the plugin. This will be shown to users who install your plugin, and also people who look up your nuget package if you decide to publish it. Authors\tThe authors of the plugin. This currently isn't shown anywhere, but it will in the future. It will also show up on your nuget package if you decide to publish it. "},{"title":"Build the project​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#build-the-project","content":"Open the project in your preferred IDE by opening the JKMP.Plugin.&lt;NameOfPlugin&gt;.sln file. Build the project and verify that there's no errors or warnings. Open the game's directory and check if there's a folder called JKMP\\Plugins\\&lt;NameOfPlugin&gt;\\ with two files: JKMP.Plugin.&lt;NameOfPlugin&gt;.dllplugin.json. If there is, you're done. If you have Core installed, you should be able to start the game and have your plugin loaded. "},{"title":"Run the project​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#run-the-project","content":"The simplest way to run the project is to just launch Jump King. Just make sure you have Core installed. However if you want a more streamlined experience, you should add a launch configuration that opens the Jump King executable. This process depends on the IDE you're using. We won't be covering that in this guide, but you can probably find it by using your preferred search engine. Attaching a debugger also works as expected if you add --debug to the launch parameters. You can add breakpoints and step through the code, etc. Launch parameters can be specified, such as --console or -c to attach a console to the game for debugging. Logs are also saved in the game's JKMP\\Logs\\ directory regardless of this flag. "},{"title":"Advanced configuration​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#advanced-configuration","content":""},{"title":"Dependencies​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#dependencies","content":"If your plugin has extra dependencies, you can configure the project to automatically copy them to the game and publish directory as well. Open the JKMP.Plugin.&lt;NameOfPlugin&gt;.csproj file in your preferred text editor. Look for the following lines: &lt;!-- Add your dependency files here following the example below --&gt; &lt;!-- &lt;DependencyFiles Include=&quot;$(TargetDir)MyDependency.dll&quot; /&gt; --&gt;  Add your dependencies below. For reference, $(TargetDir) is the project's build output folder. The files will be copied to Jump King\\JKMP\\Plugins\\&lt;NameOfPlugin&gt;\\Dependencies\\. "},{"title":"Content files​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#content-files","content":"If your plugin has content files such as textures or audio files, they will be automatically copied to the game and published directory. Any files that exist in the project's build output Content folder will be copied to Jump King\\JKMP\\Plugins\\&lt;NameOfPlugin&gt;\\Content\\. If you want to finetune this process, open the JKMP.Plugin.&lt;NameOfPlugin&gt;.csproj file in your preferred text editor. Look for the following lines: &lt;!-- Add your content files here. By default all files in the project output's Content directory will be copied to the game directory --&gt; &lt;ContentFiles Include=&quot;$(TargetDir)Content\\**\\*.*&quot; /&gt;  Modify the include pattern to match the files you want to copy. You can also add more lines. "},{"title":"Publishing​","type":1,"pageTitle":"Create a plugin using a template","url":"getting-started/project-setup/using-a-template#publishing","content":"When you want to publish your plugin, you'll need to open a command prompt/terminal and run the publish command: dotnet publish -c Release  If the command runs successfully, you should now have a folder called JKMP.Plugin.&lt;NameOfPlugin&gt;\\bin\\published_plugin\\&lt;NameOfPlugin&gt;\\ with the following files: JKMP.Plugin.&lt;NameOfPlugin&gt;.dllplugin.json And of course any other files you've added to the project, such as content or dependencies. Generally you should be able to just zip up the folder and distribute it to your users, instructing them to extract it in the Jump King\\JKMP\\Plugins\\ folder. At the moment there is no official source for plugins. "},{"title":"Input","type":0,"sectionRef":"#","url":"input","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Input","url":"input#introduction","content":"If you want to read input from the player you should use the Plugin.Input property. It brings the following advantages over using KeyboardState.GetState() etc: Allows you to either subscribe to events or poll the action every update, depending on how your plugin's workflow is set up.Allows the player to rebind the action to any key they want.Prevents multiple actions from being bound to the same key, unless the player explicitly allows it.Allows the player to bind the action to multiple keys at once, and even mixing keyboard/mouse/gamepad buttons.Plugins can add support for new input devices, and the player can bind your actions to them without you having to explicitly add support for them. "},{"title":"Examples​","type":1,"pageTitle":"Input","url":"input#examples","content":""},{"title":"Creating an action​","type":1,"pageTitle":"Input","url":"input#creating-an-action","content":"MyPlugin.cs public class MyPlugin : JKMP.Core.Plugins.Plugin { private InputManager.ActionInfo myAction; public override void CreateInputActions() { myAction = Input.CreateActionWithName( name: &quot;MyAction&quot;, // Unique name for the action. Only has to be unique in the scope of the plugin. uiName: &quot;My Action&quot;, // The name that will be displayed in the UI onlyGameInput: true, // Only allow this action to be triggered when the game is unpaused defaultKeys: &quot;a&quot;, &quot;xpad-a&quot; // Default binds to 'A' keyboard key and 'X' button (xbox layout) on controller ); } }  "},{"title":"Using an action​","type":1,"pageTitle":"Input","url":"input#using-an-action","content":"// Either bind the action to a callback: Input.BindAction(myAction, MyActionCallback); void MyActionCallback(bool pressed) { // Pressed = true if the action was just pressed, false if it was just released. } // Or poll the action every update: if (myAction.IsPressed) { // Do something }  "},{"title":"Logging","type":0,"sectionRef":"#","url":"logging","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Logging","url":"logging#introduction","content":"Core uses Serilog for logging. It is a simple, yet powerful logging framework. Log messages are displayed in the console and appended to a log file located in the JKMP\\Logs directory. This guide will only cover basic usage, but if you want to learn more you should check out the Serilog wiki. "},{"title":"Logging types​","type":1,"pageTitle":"Logging","url":"logging#logging-types","content":"There are two methods of logging you can choose from: "},{"title":"1. Contextual logger​","type":1,"pageTitle":"Logging","url":"logging#1-contextual-logger","content":"Mainly used for logging messages that should be included with the released plugin. Should not be used for temporary debugging messages. To get started, you need to add a logger to your class. This should be done for each class (and optionally context) that needs to log something. note Do not use a single logger for the entire plugin unless the plugin is very simple. MyPlugin.cs using JKMP.Core.Logging; using Serilog; public class MyPlugin : JKMP.Core.Plugins.Plugin { private static readonly ILogger Logger = LogManager.CreateLogger&lt;MyPlugin&gt;(); public MyPlugin() { Logger.Info(&quot;Hello world!&quot;); } }  "},{"title":"2. Temporary logger​","type":1,"pageTitle":"Logging","url":"logging#2-temporary-logger","content":"Mainly used for logging messages that are temporary and not meant to be included with the released plugin. It is just a static readonly ILogger called LogManager.TempLogger. caution Refrain from including this in a release as it would be difficult to locate the source of the message. MyPlugin.cs using JKMP.Core.Logging; using Serilog; public class MyPlugin : JKMP.Core.Plugins.Plugin { public MyPlugin() { LogManager.TempLogger.Info(&quot;Hello world!&quot;); } }  "},{"title":"Log configuration​","type":1,"pageTitle":"Logging","url":"logging#log-configuration","content":"If you want to change the format of the output message, or change the minimum visible logging level, you can do so by modifying the LogConfig.json file located in the JKMP directory. The documentation for the template format can be found here. The default log configuration ignores verbose messages. If you want to show verbose messages, you can do so by changing MinimumLogLevel to Verbose. note Changing the log configuration only affects your installation. Therefore changing it is only useful for development purposes. "},{"title":"Plugin Metadata","type":0,"sectionRef":"#","url":"plugin-metadata","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Plugin Metadata","url":"plugin-metadata#introduction","content":"The plugin metadata file is a JSON formatted file that contains information about the plugin. It is located in the root of the plugin directory, and is named plugin.json. It is required for the plugin to load. "},{"title":"Properties​","type":1,"pageTitle":"Plugin Metadata","url":"plugin-metadata#properties","content":"Property\tDescriptionName\tThe name of the plugin. Formatted for being displayed to the user. Description\tA short description of the plugin. Version\tThe version of the plugin. Should follow the semantic versioning scheme. Authors\tA string array containing the names of the authors of the plugin. Dependencies\tA dictionary containing the required plugins and their versions. The version is defined as a range. You can read more about the range syntax here. OnlyContent\tA boolean that determines if the plugin only contains content or not. If true then no attempt will be made to load an entry file, such as a dll file. "},{"title":"Examples​","type":1,"pageTitle":"Plugin Metadata","url":"plugin-metadata#examples","content":""},{"title":"Basic plugin​","type":1,"pageTitle":"Plugin Metadata","url":"plugin-metadata#basic-plugin","content":"Speedrun/plugin.json { &quot;name&quot;: &quot;Speedrunning Support&quot;, &quot;description&quot;: &quot;Adds support for speedrunning tools.&quot;, &quot;version&quot;: &quot;1.5.1&quot;, &quot;authors&quot;: [ &quot;Some Person&quot; ], &quot;onlyContent&quot;: false, // This property can be omitted, as false is the default value. &quot;dependencies&quot;: { } // This can also be omitted if there are no dependencies. }  "},{"title":"Plugin with a dependency​","type":1,"pageTitle":"Plugin Metadata","url":"plugin-metadata#plugin-with-a-dependency","content":"PreciseTimer/plugin.json { &quot;name&quot;: &quot;Precise Timer&quot;, &quot;description&quot;: &quot;Adds a precise timer to the speedrunning plugin.&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;authors&quot;: [ &quot;Some Other Person&quot; ], &quot;onlyContent&quot;: true, &quot;dependencies&quot;: { &quot;Speedrun&quot;: &quot;^1.5&quot; // Compatible with any version between &gt;=1.5.0 and &lt;2.0.0-0 }  "},{"title":"Plugin Configuration","type":0,"sectionRef":"#","url":"plugin-configuration","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Plugin Configuration","url":"plugin-configuration#introduction","content":"If you want customizable options for your plugin, you can register a config using the Configs property on the Plugin class. By default users will be able to change the config from the JKMP\\Config\\&lt;YourPluginName&gt; directory. You can also create a configuration menu from the config so that users can edit the config in game. "},{"title":"Examples​","type":1,"pageTitle":"Plugin Configuration","url":"plugin-configuration#examples","content":""},{"title":"Simple config​","type":1,"pageTitle":"Plugin Configuration","url":"plugin-configuration#simple-config","content":"MyPlugin.cs public class MyPlugin : JKMP.Core.Plugins.Plugin { class MyConfig { public int MyInt { get; set; } = 1; public string MyString { get; set; } public Dictionary&lt;string, string&gt; MyDictionary { get; set; } = new(); } public override void Initialize() { // Load config (or create a new one) // In a real plugin you probably want to // catch potential IO and deserialization exceptions. var myConfig = Configs.Load&lt;MyConfig&gt;(&quot;MyConfig&quot;); /* myConfig = { myInt = 1, myString = null, myDictionary = {} } */ // Modify config and save new values myConfig.MyInt = 2; Configs.SaveConfig(myConfig, &quot;MyConfig&quot;); // Reload config for testing purposes myConfig = Configs.Load&lt;MyConfig&gt;(&quot;MyConfig&quot;); /* myConfig = { myInt = 2, myString = null, myDictionary = {} }*/ } }  "},{"title":"Config with in-game menu​","type":1,"pageTitle":"Plugin Configuration","url":"plugin-configuration#config-with-in-game-menu","content":"MyPlugin.cs using JKMP.Core.Configuration.Attributes; using JKMP.Core.Configuration.UI; public class MyPlugin : JKMP.Core.Plugins.Plugin { class MyConfig { [SliderField(MinValue = 0, MaxValue = 100, StepSize = 10)] public int MyInt { get; set; } = 50; [TextField] public string MyString { get; set; } = &quot;&quot;; } public override void Initialize() { // Load config (or create a new one) // In a real plugin you probably want to // catch potential IO and deserialization exceptions. var myConfig = Configs.Load&lt;MyConfig&gt;(&quot;MyConfig&quot;); /* myConfig = { myInt = 50, myString = null } */ // Create config menu IConfigMenu menu = Configs.CreateConfigMenu&lt;MyConfig&gt;( title: &quot;My Config&quot;, // A file path // No extension assumes .json // Note that the config is always serialized // to json regardless of the extension source: &quot;MyConfig&quot; ); // When values are changed in-game they are automatically saved. // If you want to do something when a property changes // you can do it like this: menu.OnPropertyChanged += (sender, args) =&gt; { switch args.PropertyName { case nameof(MyConfig.MyInt): { // Do something when MyInt changes // Access new value either from args.Value LogManager.TempLogger.Info($&quot;MyInt changed to {args.Value}&quot;); // Or by accessing the property from the menu directly. LogManager.TempLogger.Info($&quot;MyInt changed to {menu.Values.MyInt}&quot;); break; } } } // Alternatively you can use custom getters/setters // on the config class and handle it in the class itself. }  "},{"title":"Available config value type attributes​","type":1,"pageTitle":"Plugin Configuration","url":"plugin-configuration#available-config-value-type-attributes","content":"These are the available built-in field type attributes: SliderFieldAttributeTextFieldAttributeCheckBoxFieldAttribute They should be fairly self-explanatory. Use intellisense to see the available properties. "},{"title":"Implementing a custom field renderer​","type":1,"pageTitle":"Plugin Configuration","url":"plugin-configuration#implementing-a-custom-field-renderer","content":"If you want to implement a custom field renderer, you can do so by following these steps: Create a class that inherits from SettingsOptionAttribute.Add the following attributes to the class: SettingsOptionsCreatorAttribute, and optionally AttributeUsageAttribute with validOn set to AttributeTargets.Property. The SettingsOptionsCreatorAttribute takes a type parameter. It should be the type of the ConfigPropertyCreator which we'll be implementing next. Create a class that inherits from ConfigPropertyCreator&lt;T&gt;. The T should be the type of the attribute you created in step 1.Implement the SupportedTypes property. It should return a collection of property types that the creator supports.Implement the CreateField method. It should return an IMenuItem that represents the config value. Make sure to read the intellisense if you're unsure about the method parameters.When the value is changed you should invoke the base.ValueChanged action and pass the new value. The new value will be automatically converted to the property's type for simple value types such as int and double etc. Here is the implementation of the slider as an example: using JKMP.Core.Configuration.Attributes; using JKMP.Core.Configuration.Attributes.PropertyCreators; using JKMP.Core.Configuration.UI; /// &lt;summary&gt; /// A menu field that is used to display a slider. Supported property types are &lt;see cref=&quot;float&quot;/&gt; and &lt;see cref=&quot;int&quot;/&gt; /// Note that the underlying slider value is always a &lt;see cref=&quot;float&quot;/&gt;. /// &lt;/summary&gt; [SettingsOptionCreator(typeof(SliderFieldCreator))] [AttributeUsage(AttributeTargets.Property)] public sealed class SliderFieldAttribute : SettingsOptionAttribute { /// &lt;summary&gt; /// The minimum value of the slider. 0 by default. /// &lt;/summary&gt; public float MinValue { get; set; } = 0; /// &lt;summary&gt; /// The maximum value of the slider. 1 by default. /// &lt;/summary&gt; public float MaxValue { get; set; } = 1; /// &lt;summary&gt; /// The amount to increase or decrease the slider value by when the user presses the left or right arrow keys. 0.1 by default. /// &lt;/summary&gt; public float StepSize { get; set; } = 0.1f; } internal class SliderFieldCreator : ConfigPropertyCreator&lt;SliderFieldAttribute&gt; { public override ICollection&lt;Type&gt; SupportedTypes =&gt; new List&lt;Type&gt; { typeof(float), typeof(int) }; public override IMenuItem CreateField(object config, string fieldName, PropertyInfo propertyInfo, SliderFieldAttribute attribute, List&lt;IDrawable&gt; drawables) { var result = new SliderField(fieldName, (float)Convert.ChangeType(propertyInfo.GetValue(config), TypeCode.Single), attribute.MinValue, attribute.MaxValue, attribute.StepSize); result.ValueChanged += val =&gt; { ValueChanged?.Invoke(val); }; return result; } }  The slider menu item implementation has been omitted from the example to keep it short and in scope. If you want to see the source for it you can find it here. "}]